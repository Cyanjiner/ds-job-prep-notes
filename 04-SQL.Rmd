# Database Management and Data Systems (SQL)

```{r setup, include=FALSE}
library(RSQLite)
library(DBI)
library(knitr)
db <- dbConnect(RSQLite::SQLite(), ":memory:")
knitr::opts_chunk$set(eval=FALSE, echo=TRUE)
knitr::opts_chunk$set(connection = "db")
```

`Database schemas` show `data types` for each field (column) in all tables (data frame), and they also show `relationships` between tables.

`SQL (Structured Query Language)` is used to answer questions / extract information both within and across relational database tables

[SQL Style Guide by Simon Holywell](https://www.sqlstyle.guide/) *Keywords* are reserved words for **operations**.

## Common keywords and examples:

### CRUD operations

-   CREATE ---\> Databases \| Tables \| Views \| Users \| Permissions \| Security Groups

```{sql }
/* create a new table w/ column names, data type, size */
CREATE TABLE test_table( -- unique table name
  test_date date,
  test_name varchar(20),
  test_int int
)

/* data types: */
Dates: date (YYYY-MM-DD) | datetime (YYYY-MM-DD hh:mm:ss) | time
Numeric: int | decimal | float | bit (1=TRUE, 0=FALSE. Also accepts NULL)
Strings: char | varchar | nvarchar

/* create a copy of an existing table */
CREATE TABLE new_table_name AS
    SELECT column1, column2, ...
    FROM existing_table_name,
    WEHRE conditions;
```

-   INSERT, --- insert new records into existing database tables

```{sql }
/* insert new columns & values */
INSERT INTO table_name (col1, col2, col3)
VALUES
  ('value1', 'value2', 'value3')
  
/* insert + select columns & values from another existing table */
INSERT INTO table_name (col1, col2, col3)
SELECT
  column1,
  column2,
  column3
FROM other_table
WHERE condition(s);
```

-   UPDATE --- Amend existing database records

```{sql}
UPDATE table_name
SET 
  column1 = value1,
  column2 = value2
WHERE condition(s)
```

-   DELETE --- delete existing records from tables

```{sql}
DELETE 
FROM table_name
WHERE condition(s)

/* another method: TRUNCATE --> remove all data from ALL columns at once */
TRUNCATE TABLE table_name
```

-   Declare Variables ---\> so it will be easier to use in later conditions without repetitively calling the same values

```{sql}
-- declare your variables
DECLARE @start DATE
DECLARE @stop DATE
DECLARE @affected INT;

-- set relevant values for each variable
SET @start = '2022-01-01'
SET @stop = '2022-12-31'
SET @affected = 5000; -- threshold for # of affected customers

SELECT 
  column1,
  column2,
  affected_customers
FROM 
  table_name
WHERE date BETWEEN @start AND @stop
AND affected_customers >= @affected;
```

-   Temporary tables

```{sql}
SELECT
  col1,
  col2,
  col3 INTO #my_temp_table -- #my_temp_table exists until connection or session ends
FROM my_existing_table
WHERE condition(s);

-- Remove table manually
DROP TABLE #my_temp_table
```

-   READ

    -   Example: `SELECT` statements

        -   `SELECT` indicates which *fields* should be selected.

        -   `FROM` indicates where these *fields* are located.

        -   `SELECT DISTINCT` allows you to select field content.

```{sql}
SELECT DISTINCT var_name1 AS new_var_name1, var_name2
FROM table_name;
```

`DROP DATABASE` drops an existing SQL database

`ALTER DATABASE` modifies a database

`ALTER TABLE` modifies a table `DROP TABLE table_name` deletes a table `CREATE INDEX` creates an index (search key) `DROP INDEX` deletes an index `BACKUP DATABASE` is used in SQL Server to create a full back up of an existing SQL database `TO DIST = 'filepath';` Use *aliasing* to rename columns:

*View* is a virtual table that is the result of a saved `SELECT` statement. When accessed, views automatically update in response to updates in the underlying data.

```{sql}
CREATE VIEW new_table_name AS
SELECT id, var_name1, var_name2
FROM table_name;
```

Group by \| Having \| WHERE

-   `GROUP BY` splits data up into combinations of one or more values

-   `WHERE` filters on row values

-   `HAVING` appears ***after*** the `GROUP BY` clause and ***filters*** on groups or aggregates

```{sql}
/* List the number of customers in each country, ordered by the country with the most customers first.*/
SELECT COUNT(customerID),
country,
FROM customers
GROUP BY country
ORDER BY COUNT(customerID) DESC; 

/* List the # of customers in each country, sorted high to low (but only include countries with more than 5 customers) */
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5
ORDER BY COUNT(CustomerID) DESC;

/* List if the employees "Davolio" or "Fuller" have registered more than 25 orders */
SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders
FROM Orders
INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
WHERE LastName = 'Davolio' OR LastName = 'Fuller'
GROUP BY LastName 
HAVING COUNT(Orders.OrderID) > 25;
```

Join examples

```{sql}
/* INNER JOIN selects records that have matching values in BOTH tables */
SELECT column_name
FROM table1
INNER JOIN table2 ON table1.column_name = table2.column_name;

/* LEFT JOIN selects all records from the left table (table1) and the matching records from the right table (table2) */
SELECT column_name
FROM table1
LEFT JOIN table2 ON table1.column_name = table2.column_name;

/* RIGHT JOIN selects all records from the right table (table2) and the matching records from the left table (table1) */
SELECT column_name
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;

/* FULL OUTER JOIN returns all records when there is a match in left (table1) OR right (table2) table records -- FULL OUTER JOIN == FULL JOIN */
SELECT column_name
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;

/* a self join is a regular join, but the table is joined with itself */
SELECT column_name
FROM table1 T1, table2 T2 -- T1, T2 are two aliases of table 1 and table 2
WHERE condition

/* SQL Self Join Example: matching customers from the same city */
SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID <> B.CustomerID -- <> stands for not equal 
AND A.City = B.City
ORDER BY A.City;
```

The SQL UNION Operator

-   `UNION` discards duplicates while `UNION ALL` does not

-   the `UNION` operator is used to combine the result-set of two or more `SELECT` statements

    -   Every `SELECT` statement within UNION must have the same number of columns

    -   The columns must also have similar data types

    -   The columns in every `SELECT` statement must also be in the same order

    ```{sql}
    /* UNION : selects only distinct values by default */
    SELECT column_name(s) FROM table1
    UNION
    SELECT column_name(s) FROM table2;

    /* UNION ALL : allows duplicate values */
    SELECT column_name(s) FROM table1
    UNION ALL
    SELECT column_name(s) FROM table2;

    /* example1: returns the German cities (duplicate values also) from both the customers and the suppliers table */
    SELECT City, Country FROM Customers
    WHERE Country='Germany'
    UNION ALL
    SELECT City, Country FROM Suppliers
    WHERE Country='Germany'
    ORDER BY City;
    ```

CASE statements can be used to create columns (new variables) for

-   categorizing data

-   filtering data

-   aggregating data based on results of a logical test

    -   e.g. `COUNT(CASE statement)`--\>returns the number of rows returned by case statements instead of string / text

    -   similar aggregations include SUM/AVG/ROUND(AVG(...), digits)

    -   Percentages with CASE and AVG

```{sql}
SELECT 
  column1,
  ROUND(AVG(CASE WHEN condition1 AND condition2 THEN 0
                 WHEN condition1 AND condition3 THEN 1 
                 END), 2) AS pct_column,
FROM table1
GROUP BY column1
```

```{sql }
SELECT
  id,
  home_goal,
  away_goal,
  CASE WHEN home_goal > away_goal THEN 'Home Team Win'
       WHEN home_goal < away_goal THEN 'Away Team Win'
       ELSE 'Tie' END AS outcome
    /* ELSE NULL AS outcome --> if everything else should be N.A.
       END AS outcome --> if we want to exclude every other conditions 
       END IS NOT NULL --> keep all clauses excluding missing values*/
FROM match
WHERE season = '2013/2014';

/* Example 1: CASE WHEN + COUNT GROUP BY */
-- Identify the home team as Bayern Munich, Schalke 04, or neither
SELECT 
    CASE WHEN hometeam_id = 10189 THEN 'FC Schalke 04'
         WHEN hometeam_id = 9823 THEN 'FC Bayern Munich'
         ELSE 'Other' END AS home_team,
    COUNT(id) AS total_matches
FROM matches_germany
-- Group by the CASE statement alias
GROUP BY home_team;

/* Example 2: CASE WHEN + LEFT JOIN + WHERE */
SELECT 
	m.date,
	t.team_long_name AS opponent,
    -- Complete the CASE statement with an alias
	CASE WHEN m.home_goal > away_goal THEN 'Barcelona win!'
       WHEN m.home_goal < away_goal THEN 'Barcelona loss :(' 
       ELSE 'Tie' END AS outcome 
FROM matches_spain AS m
LEFT JOIN teams_spain AS t 
ON m.awayteam_id = t.team_api_id
-- Filter for Barcelona as the home team
WHERE m.hometeam_id = 8634; 
```

TEXT operations

```{sql }
SELECT 
  colunm,
  LEN(column) AS column_length -- returns # of chars
  LEFT(column, 20) AS first_20_left_column -- returns first 20 chars from the LEFT
  RIGHT(column, 20) AS last_20_column -- returns last 20 chars from the RIGHT
  CHARINDEX('_', column) AS char_location -- returns the index of a char/string in column
  SUBSTRING(column, start, length) AS target_section 
        -- returns substring starting at location 12 and has length of 12
FROM table;

/* REPLACE */
SELECT
  TOP(5) REPLACE(column, 'a','b') AS replaced_column_with_b
        -- replaces char 'a' in column with char 'b' for all first 5 rows
FROM table;
```
